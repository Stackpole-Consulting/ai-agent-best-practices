# AI Agent Context: Python FastAPI Task Manager

> **Project:** Task Manager REST API  
> **Framework:** Stackpole Consulting AI Agent Best Practices  
> **Stack:** Python 3.11+ / FastAPI / PostgreSQL / SQLAlchemy

## Project Overview

A production-ready REST API for task management demonstrating AI agent best practices. This API allows users to create accounts, manage tasks with priorities and statuses, and collaborate on task completion.

**Key Features:**
- User authentication with JWT
- CRUD operations for tasks
- Task filtering and pagination
- Priority and status management
- Comprehensive validation
- Full test coverage

## Project Structure

```
src/
├── api/                    # API routes and endpoints
│   ├── v1/                # API version 1
│   │   ├── tasks.py       # Task endpoints
│   │   └── users.py       # User/auth endpoints
│   ├── dependencies.py    # FastAPI dependency injection
│   └── middleware.py      # Custom middleware
├── core/                  # Core configuration and utilities
│   ├── config.py          # Pydantic Settings
│   ├── database.py        # SQLAlchemy setup
│   └── security.py        # Password hashing, JWT
├── models/                # SQLAlchemy ORM models
│   ├── user.py            # User database model
│   └── task.py            # Task database model
├── schemas/               # Pydantic validation schemas
│   ├── user.py            # User DTOs
│   └── task.py            # Task DTOs
├── services/              # Business logic layer
│   ├── user_service.py    # User operations
│   └── task_service.py    # Task operations
└── main.py               # FastAPI application entry

tests/
├── conftest.py           # Pytest fixtures (test database, client)
├── unit/                 # Fast, isolated tests
│   ├── test_services.py  # Business logic tests
│   └── test_validation.py # Pydantic validation tests
├── integration/          # Tests with database
│   └── test_api.py       # API endpoint tests
└── e2e/                  # Full workflow tests
    └── test_workflows.py # User scenarios
```

## Architecture Principles

### **Layered Architecture**

We use strict separation of concerns:

```python
# 1. API Layer (src/api/v1/) - HTTP concerns only
#    - Route definitions
#    - Request/response handling
#    - Authentication checks
#    - NO business logic

# 2. Schema Layer (src/schemas/) - Data validation
#    - Pydantic models for request/response
#    - Field validation rules
#    - Data transformation
#    - NO database access

# 3. Service Layer (src/services/) - Business logic
#    - Domain operations
#    - Business rule enforcement
#    - Transaction management
#    - NO HTTP concerns

# 4. Model Layer (src/models/) - Data persistence
#    - SQLAlchemy models
#    - Database relationships
#    - Column definitions
#    - NO business logic
```

### **Dependency Injection**

Use FastAPI's dependency injection for all dependencies:

```python
# ✅ CORRECT: Inject dependencies
@router.post("/tasks")
async def create_task(
    task_data: TaskCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    return await task_service.create(db, task_data, current_user.id)

# ❌ INCORRECT: Don't create dependencies inside functions
@router.post("/tasks")
async def create_task(task_data: TaskCreate):
    db = SessionLocal()  # BAD: Can't test, hard to mock
    # ...
```

## Coding Standards

### **Type Hints (Required)**

All functions must have type hints:

```python
# ✅ CORRECT: Full type hints
async def create_task(
    db: AsyncSession,
    task_data: TaskCreate,
    user_id: int
) -> Task:
    """Create a new task for a user.
    
    Args:
        db: Database session
        task_data: Validated task creation data
        user_id: ID of user creating the task
    
    Returns:
        Created Task instance
        
    Raises:
        ValidationError: If task data invalid
        UserNotFoundError: If user doesn't exist
    """
    # Implementation
    pass

# ❌ INCORRECT: Missing type hints
async def create_task(db, task_data, user_id):
    # Missing return type and parameter types
    pass
```

### **Pydantic Schemas**

Use Pydantic V2 for all data validation:

```python
from pydantic import BaseModel, Field, field_validator, ConfigDict
from typing import Literal

class TaskCreate(BaseModel):
    """Schema for creating a new task."""
    
    title: str = Field(
        ..., 
        min_length=1, 
        max_length=200,
        description="Task title"
    )
    description: str | None = Field(
        None,
        max_length=2000,
        description="Detailed task description"
    )
    priority: Literal["low", "medium", "high", "urgent"] = Field(
        default="medium",
        description="Task priority level"
    )
    status: Literal["pending", "in_progress", "completed", "cancelled"] = Field(
        default="pending",
        description="Current task status"
    )
    
    @field_validator("title")
    @classmethod
    def title_must_not_be_empty(cls, v: str) -> str:
        """Ensure title is not just whitespace."""
        if not v.strip():
            raise ValueError("Title cannot be empty or whitespace")
        return v.strip()
    
    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "title": "Implement user authentication",
                "description": "Add JWT-based auth to the API",
                "priority": "high",
                "status": "in_progress"
            }
        }
    )
```

### **SQLAlchemy Models**

Use SQLAlchemy 2.0 declarative style with type hints:

```python
from sqlalchemy import String, Text, Integer, DateTime, ForeignKey, Enum
from sqlalchemy.orm import Mapped, mapped_column, relationship
from datetime import datetime
import enum

class TaskStatus(enum.Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    CANCELLED = "cancelled"

class Task(Base):
    __tablename__ = "tasks"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    title: Mapped[str] = mapped_column(String(200), nullable=False)
    description: Mapped[str | None] = mapped_column(Text)
    priority: Mapped[str] = mapped_column(String(20), default="medium")
    status: Mapped[TaskStatus] = mapped_column(
        Enum(TaskStatus),
        default=TaskStatus.PENDING
    )
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"))
    created_at: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.utcnow
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow
    )
    
    # Relationships
    user: Mapped["User"] = relationship(back_populates="tasks")
```

### **Error Handling**

Use custom exceptions with proper HTTP status mapping:

```python
# Define custom exceptions
class TaskNotFoundError(Exception):
    """Raised when task doesn't exist."""
    pass

class UnauthorizedTaskAccessError(Exception):
    """Raised when user tries to access task they don't own."""
    pass

# Service layer raises domain exceptions
async def get_task(db: AsyncSession, task_id: int, user_id: int) -> Task:
    task = await db.get(Task, task_id)
    if not task:
        raise TaskNotFoundError(f"Task {task_id} not found")
    if task.user_id != user_id:
        raise UnauthorizedTaskAccessError("Cannot access another user's task")
    return task

# API layer handles HTTP responses
from fastapi import HTTPException

@app.exception_handler(TaskNotFoundError)
async def task_not_found_handler(request, exc):
    raise HTTPException(status_code=404, detail=str(exc))

@app.exception_handler(UnauthorizedTaskAccessError)
async def unauthorized_access_handler(request, exc):
    raise HTTPException(status_code=403, detail=str(exc))
```

### **Testing Patterns**

Write tests at three levels:

```python
# 1. UNIT TESTS - Fast, no database
# tests/unit/test_validation.py
def test_task_create_validates_title():
    """Test Pydantic validation without database."""
    with pytest.raises(ValidationError):
        TaskCreate(title="")  # Empty title should fail
    
    with pytest.raises(ValidationError):
        TaskCreate(title="x" * 201)  # Too long should fail

# 2. INTEGRATION TESTS - With test database
# tests/integration/test_task_service.py
async def test_create_task(db_session, test_user):
    """Test task creation with database."""
    task_data = TaskCreate(
        title="Test Task",
        priority="high"
    )
    
    task = await task_service.create(db_session, task_data, test_user.id)
    
    assert task.id is not None
    assert task.title == "Test Task"
    assert task.user_id == test_user.id

# 3. E2E TESTS - Full API requests
# tests/e2e/test_workflows.py
async def test_complete_task_workflow(client, auth_headers):
    """Test complete user workflow."""
    # Create task
    response = await client.post(
        "/api/v1/tasks",
        json={"title": "Test Task", "priority": "high"},
        headers=auth_headers
    )
    assert response.status_code == 201
    task = response.json()
    
    # Update task status
    response = await client.patch(
        f"/api/v1/tasks/{task['id']}",
        json={"status": "completed"},
        headers=auth_headers
    )
    assert response.status_code == 200
    assert response.json()["status"] == "completed"
```

## Database Patterns

### **Async Sessions**

Always use async database operations:

```python
# ✅ CORRECT: Async operations
async def get_user_tasks(db: AsyncSession, user_id: int) -> list[Task]:
    result = await db.execute(
        select(Task).where(Task.user_id == user_id)
    )
    return result.scalars().all()

# ❌ INCORRECT: Sync operations
def get_user_tasks(db: Session, user_id: int) -> list[Task]:
    return db.query(Task).filter(Task.user_id == user_id).all()
```

### **Transaction Management**

Let the service layer handle transactions:

```python
async def update_task(
    db: AsyncSession,
    task_id: int,
    task_data: TaskUpdate,
    user_id: int
) -> Task:
    """Update task with transaction."""
    # Get task
    task = await get_task(db, task_id, user_id)
    
    # Update fields
    for field, value in task_data.model_dump(exclude_unset=True).items():
        setattr(task, field, value)
    
    # Commit handled by router via dependency
    await db.commit()
    await db.refresh(task)
    
    return task
```

## API Design Standards

### **RESTful Routes**

Follow REST conventions:

```python
# ✅ CORRECT: RESTful resource routes
GET     /api/v1/tasks           # List all tasks
POST    /api/v1/tasks           # Create task
GET     /api/v1/tasks/{id}      # Get specific task
PATCH   /api/v1/tasks/{id}      # Update task (partial)
PUT     /api/v1/tasks/{id}      # Replace task (full)
DELETE  /api/v1/tasks/{id}      # Delete task

# ❌ INCORRECT: Non-RESTful routes
GET     /api/v1/getTasks
POST    /api/v1/createTask
POST    /api/v1/tasks/delete/{id}
```

### **Response Format**

Always return consistent JSON:

```python
# Single resource
{
    "id": 1,
    "title": "Task title",
    "status": "in_progress",
    "created_at": "2025-10-24T10:00:00Z"
}

# List with pagination
{
    "items": [...],
    "total": 100,
    "page": 1,
    "page_size": 20,
    "pages": 5
}

# Error response
{
    "error": "task_not_found",
    "message": "Task 123 not found",
    "details": {
        "task_id": 123
    }
}
```

## Security Guidelines

### **Password Hashing**

Always hash passwords with bcrypt:

```python
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# Hash password before storing
hashed_password = pwd_context.hash(plain_password)

# Verify password during login
is_valid = pwd_context.verify(plain_password, hashed_password)
```

### **JWT Tokens**

Use short-lived access tokens:

```python
from datetime import datetime, timedelta
from jose import jwt

def create_access_token(data: dict) -> str:
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(hours=24)
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm="HS256")
```

### **Input Validation**

Always validate and sanitize inputs:

```python
# Pydantic handles most validation, but add custom validators for:
# - Email format
# - Password strength
# - Business rule validation
# - Cross-field validation

@field_validator("email")
@classmethod
def email_must_be_valid(cls, v: str) -> str:
    if not re.match(r"[^@]+@[^@]+\.[^@]+", v):
        raise ValueError("Invalid email format")
    return v.lower()  # Normalize to lowercase
```

## AI Agent Guidance

### **When Generating New Code**

1. **Always follow existing patterns** - Look at similar files for reference
2. **Add type hints** - All parameters and return types
3. **Include docstrings** - Explain purpose, args, returns, raises
4. **Write tests first** - TDD approach
5. **Use dependency injection** - No hardcoded dependencies
6. **Handle errors properly** - Use custom exceptions
7. **Validate inputs** - Pydantic schemas for all external data

### **Common AI Prompts That Work Well**

```markdown
✅ "Add a new field 'due_date' to tasks following the pattern in task.py"
✅ "Create tests for the task creation service following test_user_service.py"
✅ "Add pagination to GET /tasks endpoint using the standard pagination pattern"
✅ "Implement task filtering by status and priority with query parameters"

❌ "Add tasks" (too vague)
❌ "Make it better" (no specific guidance)
❌ "Fix the bug" (need error details and context)
```

### **Code Review Checklist for AI-Generated Code**

- [ ] Type hints present on all functions
- [ ] Pydantic schemas used for validation
- [ ] Async/await used correctly
- [ ] Tests written and passing
- [ ] Error handling implemented
- [ ] Docstrings added
- [ ] Follows existing patterns
- [ ] No hardcoded values (use config)
- [ ] Security considerations addressed
- [ ] Database migrations created if needed

## Environment Variables

```bash
# Database
DATABASE_URL=postgresql+asyncpg://postgres:postgres@localhost:5432/taskmanager

# Security
SECRET_KEY=your-secret-key-change-in-production
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_HOURS=24

# Application
API_V1_PREFIX=/api/v1
PROJECT_NAME=Task Manager API
DEBUG=True

# CORS
ALLOWED_ORIGINS=http://localhost:3000,http://localhost:8000
```

## Common Tasks

### **Create Database Migration**

```bash
# Auto-generate migration from model changes
alembic revision --autogenerate -m "Add due_date to tasks"

# Review generated migration in alembic/versions/

# Apply migration
alembic upgrade head
```

### **Add New Endpoint**

1. Define Pydantic schema in `src/schemas/`
2. Add business logic in `src/services/`
3. Create route in `src/api/v1/`
4. Write tests in `tests/`
5. Update API docs if needed

### **Debug Database Queries**

```python
# Enable SQL logging in config
import logging
logging.basicConfig()
logging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)

# Will print all SQL queries to console
```

---

**Version:** 1.0.0  
**Framework:** Stackpole Consulting AI Agent Best Practices  
**Last Updated:** 2025-10-24  
**For Questions:** Review framework docs in parent directories